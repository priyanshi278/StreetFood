import React, { useState, useEffect } from "react";
import { Mic, MicOff, Loader2 } from "lucide-react";
import { useVoiceRecognition } from "../hooks/useVoiceRecognition";
import { useCart } from "../contexts/CartContext";
import { collection, getDocs } from "firebase/firestore";
import { db } from "../firebase/config";
import { Product } from "../types";

// üîπ Tokenize text
const tokenize = (text: string) =>
  text.toLowerCase().replace(/[^a-zA-Z0-9\u0900-\u097F\s]/g, "").split(/\s+/);

// üîπ Levenshtein Distance
const levenshtein = (a: string, b: string) => {
  const dp = Array.from({ length: a.length + 1 }, () => Array(b.length + 1).fill(0));
  for (let i = 0; i <= a.length; i++) dp[i][0] = i;
  for (let j = 0; j <= b.length; j++) dp[0][j] = j;

  for (let i = 1; i <= a.length; i++) {
    for (let j = 1; j <= b.length; j++) {
      dp[i][j] =
        a[i - 1] === b[j - 1]
          ? dp[i - 1][j - 1]
          : 1 + Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]);
    }
  }
  return dp[a.length][b.length];
};

// üîπ Synonyms
const productSynonyms: Record<string, string[]> = {
  onion: ["onion", "pyaz", "‡§™‡•ç‡§Ø‡§æ‡§ú"],
  tomatoes: ["tomato", "tamatar", "‡§ü‡§Æ‡§æ‡§ü‡§∞", "tomatoes"],
  potatoes: ["potato", "aloo", "‡§Ü‡§≤‡•Ç", "potatoes"],
  capsicum: ["capsicum", "shimla mirch", "‡§∂‡§ø‡§Æ‡§≤‡§æ ‡§Æ‡§ø‡§∞‡•ç‡§ö", "bell pepper"],
  cabbage: ["cabbage", "patta gobhi", "‡§™‡§§‡•ç‡§§‡§æ ‡§ó‡•ã‡§≠‡•Ä"],
  cauliflower: ["cauliflower", "phool gobhi", "‡§´‡•Ç‡§≤ ‡§ó‡•ã‡§≠‡•Ä"],
  carrot: ["carrot", "gajar", "‡§ó‡§æ‡§ú‡§∞"],
  beetroot: ["beetroot", "chakundar", "‡§ö‡§ï‡•Å‡§Ç‡§¶‡§∞"],
  ginger: ["ginger", "adrak", "‡§Ö‡§¶‡§∞‡§ï"],
  garlic: ["garlic", "lehsun", "‡§≤‡§π‡§∏‡•Å‡§®"],
  green_chilli: ["green chilli", "hari mirch", "‡§π‡§∞‡•Ä ‡§Æ‡§ø‡§∞‡•ç‡§ö", "chillies"],
  coriander: ["coriander", "dhaniya", "‡§ß‡§®‡§ø‡§Ø‡§æ", "cilantro"],
  spinach: ["spinach", "palak", "‡§™‡§æ‡§≤‡§ï"],
  peas: ["peas", "matar", "‡§Æ‡§ü‡§∞", "green peas"],
  lemon: ["lemon", "nimbu", "‡§®‡•Ä‡§Ç‡§¨‡•Ç"],
  radish: ["radish", "mooli", "‡§Æ‡•Ç‡§≤‡•Ä"],
  pumpkin: ["pumpkin", "kaddu", "‡§ï‡§¶‡•ç‡§¶‡•Ç"],
  paneer: ["paneer", "‡§™‡§®‡•Ä‡§∞", "cottage cheese"],
  milk: ["milk", "doodh", "‡§¶‡•Ç‡§ß"],
  curd: ["curd", "dahi", "‡§¶‡§π‡•Ä", "yogurt"],
  butter: ["butter", "makhan", "‡§Æ‡§ï‡•ç‡§ñ‡§®"],
  ghee: ["ghee", "‡§ò‡•Ä", "clarified butter"],
  cheese: ["cheese", "cheddar", "mozzarella"],
  cream: ["cream", "malai", "‡§Æ‡§≤‡§æ‡§à"],
  lassi: ["lassi", "‡§≤‡§∏‡•ç‡§∏‡•Ä"],
  atta: ["atta", "flour", "aata", "‡§Ü‡§ü‡§æ", "wheat flour"],
  maida: ["maida", "‡§Æ‡•à‡§¶‡§æ", "refined flour"],
  rice: ["rice", "chawal", "‡§ö‡§æ‡§µ‡§≤"],
  poha: ["poha", "flattened rice", "‡§™‡•ã‡§π‡§æ"],
  suji: ["suji", "semolina", "‡§∏‡•Ç‡§ú‡•Ä", "rava"],
  besan: ["besan", "gram flour", "‡§¨‡•á‡§∏‡§®"],

  // ‚úÖ Bread Variants
  bread: ["bread", "loaf", "slice", "‡§¨‡•ç‡§∞‡•á‡§°", "‡§™‡§æ‡§µ"],
  white_bread: ["white bread", "‡§∏‡§´‡•á‡§¶ ‡§¨‡•ç‡§∞‡•á‡§°", "normal bread"],
  brown_bread: ["brown bread", "‡§¨‡•ç‡§∞‡§æ‡§â‡§® ‡§¨‡•ç‡§∞‡•á‡§°", "whole wheat bread"],

  bun: ["bun", "‡§™‡§æ‡§µ", "bread bun"],
  egg: ["egg", "anda", "‡§Ö‡§Ç‡§°‡§æ"],
  chicken: ["chicken", "‡§Æ‡•Å‡§∞‡•ç‡§ó‡§æ", "murgi", "‡§ö‡§ø‡§ï‡§®"],
  mutton: ["mutton", "goat meat", "‡§Æ‡§ü‡§®"],
  fish: ["fish", "‡§Æ‡§õ‡§≤‡•Ä", "machhli"],
  salt: ["salt", "namak", "‡§®‡§Æ‡§ï"],
  turmeric: ["turmeric", "haldi", "‡§π‡§≤‡•ç‡§¶‡•Ä"],
  chilli_powder: ["chilli powder", "lal mirch", "‡§≤‡§æ‡§≤ ‡§Æ‡§ø‡§∞‡•ç‡§ö"],
  cumin: ["cumin", "jeera", "‡§ú‡•Ä‡§∞‡§æ"],
  hing: ["hing", "asafoetida", "‡§π‡•Ä‡§Ç‡§ó"],
  garam_masala: ["garam masala", "‡§ó‡§∞‡§Æ ‡§Æ‡§∏‡§æ‡§≤‡§æ"],
  chole_masala: ["chole masala", "‡§õ‡•ã‡§≤‡•á ‡§Æ‡§∏‡§æ‡§≤‡§æ"],
  chat_masala: ["chat masala", "‡§ö‡§æ‡§ü ‡§Æ‡§∏‡§æ‡§≤‡§æ"],
  black_pepper: ["black pepper", "kali mirch", "‡§ï‡§æ‡§≤‡•Ä ‡§Æ‡§ø‡§∞‡•ç‡§ö"],
  oil: ["oil", "tel", "‡§§‡•á‡§≤", "cooking oil", "refined oil"],
  mustard_oil: ["mustard oil", "sarson ka tel", "‡§∏‡§∞‡§∏‡•ã‡§Ç ‡§ï‡§æ ‡§§‡•á‡§≤"],
  sugar: ["sugar", "chini", "‡§ö‡•Ä‡§®‡•Ä"],
  jaggery: ["jaggery", "gud", "‡§ó‡•Å‡§°‡§º"],
  sev: ["sev", "bhujia", "‡§∏‡•á‡§µ", "‡§≠‡•Å‡§ú‡§ø‡§Ø‡§æ"],
  puri: ["puri", "‡§™‡•Ç‡§∞‡•Ä"],
  papdi: ["papdi", "‡§™‡§æ‡§™‡§°‡§º‡•Ä"],
  samosa: ["samosa", "‡§∏‡§Æ‡•ã‡§∏‡§æ"],
  kachori: ["kachori", "‡§ï‡§ö‡•å‡§∞‡•Ä"],
  pav: ["pav", "‡§™‡§æ‡§µ", "bun"],
  bhature: ["bhature", "‡§≠‡§ü‡•Ç‡§∞‡•á"],
  noodles: ["noodles", "‡§ö‡§æ‡§â‡§Æ‡•Ä‡§®", "chowmein"],
  sauce: ["sauce", "chutney", "‡§∏‡•â‡§∏", "‡§ö‡§ü‡§®‡•Ä"],
};


// üîπ Find closest product
const findClosestProducts = (word: string, products: Product[]): Product[] => {
  let matches: { product: Product; score: number }[] = [];

  products.forEach((p) => {
    const baseName = p.name.toLowerCase().trim();

    if (baseName.includes(word) || word.includes(baseName)) {
      matches.push({ product: p, score: 0 });
    } else {
      const synonyms = productSynonyms[baseName]
        ? Array.from(new Set([...productSynonyms[baseName], baseName]))
        : [baseName];

      synonyms.forEach((syn) => {
        const score = levenshtein(word, syn.trim());
        if (score < 2) matches.push({ product: p, score });
      });
    }
  });

  if (matches.length === 0) return [];

  const minScore = Math.min(...matches.map((m) => m.score));
  const filteredMatches = matches.filter((m) => m.score === minScore);

  const cheapest = filteredMatches.reduce((prev, curr) =>
    curr.product.price < prev.product.price ? curr : prev
  );

  return [cheapest.product];
};

// üîπ Parse Voice Order
const parseVoiceOrder = (text: string, products: Product[]) => {
  const numMap: Record<string, string> = {
    ek: "1",
    do: "2",
    teen: "3",
    char: "4",
    paanch: "5",
    one: "1",
    two: "2",
    three: "3",
    four: "4",
    five: "5",
    ‡§è‡§ï: "1",
    ‡§¶‡•ã: "2",
    ‡§§‡•Ä‡§®: "3",
    ‡§ö‡§æ‡§∞: "4",
    ‡§™‡§æ‡§Å‡§ö: "5",
    ‡§™‡§æ‡§Ç‡§ö: "5",
  };

  const words = tokenize(text).map((w) => numMap[w] || w);
  const items: { product: Product; quantity: number }[] = [];
  const notFound: string[] = [];

  for (let i = 0; i < words.length; i++) {
    let qty = 1;
    let word = words[i];

    if (!isNaN(Number(word))) {
      qty = Number(word);
      i++;
      word = words[i];
      if (!word) continue;
    }

    const matches = findClosestProducts(word, products);
    if (matches.length > 0) {
      const match = matches[0];

      if (!match.supplierName) {
        notFound.push(word);
        continue;
      }

      const existing = items.find((it) => it.product.id === match.id);
      if (existing) existing.quantity += qty;
      else items.push({ product: match, quantity: qty });
    } else if (word && isNaN(Number(word))) {
      notFound.push(word);
    }
  }

  return { items, notFound };
};

const VoiceOrderAssistant: React.FC = () => {
  const [language, setLanguage] = useState("hi-IN");
  const [products, setProducts] = useState<Product[]>([]);
  const [processing, setProcessing] = useState(false);
  const [orderResult, setOrderResult] = useState("");

  const { addToCart } = useCart();
  const { isListening, startListening, stopListening, resetTranscript, isSupported } =
    useVoiceRecognition();

  // ‚úÖ Fetch products & suppliers
  useEffect(() => {
    const fetchProductsWithSuppliers = async () => {
      // 1Ô∏è‚É£ Fetch all suppliers
      const supplierSnap = await getDocs(collection(db, "users"));
      const supplierMap: Record<string, string> = {};
      supplierSnap.forEach((doc) => {
        supplierMap[doc.id.trim()] = doc.data().name || "Supplier";
      });

      // 2Ô∏è‚É£ Fetch all products
      const productSnap = await getDocs(collection(db, "products"));
      const productsData = productSnap.docs.map((doc) => {
        const p = doc.data();
        const supplierId = (p.supplierId || "").trim();

        return {
          id: doc.id,
          name: (p.name || "").toLowerCase().trim(),
          price: p.price || 0,
          unit: p.unit || "",
          supplierId,
          supplierName: supplierMap[supplierId] || null, // ‚úÖ FIXED
        };
      });

      setProducts(productsData as Product[]);
    };

    fetchProductsWithSuppliers();
  }, []);

  const processOrder = (text: string) => {
    if (!text.trim()) {
      setOrderResult("‚ùå Could not understand your order.");
      return;
    }

    setProcessing(true);
    const { items, notFound } = parseVoiceOrder(text, products);

    if (items.length === 0) {
      setTimeout(() => {
        setProcessing(false);
        setOrderResult("‚ùå No valid items found.");
      }, 1200);
      return;
    }

    items.forEach((i) => {
      for (let x = 0; x < i.quantity; x++) {
        addToCart({
          id: i.product.id,
          name: i.product.name,
          price: i.product.price,
          unit: i.product.unit,
          supplierId: i.product.supplierId,
          supplierName: i.product.supplierName || "Supplier",
        });
      }
    });

    let msg = `‚úÖ Added: ${items
      .map((i) => `${i.quantity} ${i.product.name} (Supplier: ${i.product.supplierName})`)
      .join(", ")}`;

    if (notFound.length > 0) msg += ` | ‚ùå Not Found: ${notFound.join(", ")}`;

    setTimeout(() => {
      setProcessing(false);
      setOrderResult(msg);

      if ("speechSynthesis" in window) {
        const utter = new SpeechSynthesisUtterance(msg);
        utter.lang = language;
        speechSynthesis.speak(utter);
      }
    }, 1200);
  };

  const handleMicClick = () => {
    if (isListening) stopListening();
    else {
      resetTranscript();
      startListening(language, processOrder);
    }
  };

  if (!isSupported) return <p>‚ùå Browser not supported</p>;

  return (
    <div className="max-w-md mx-auto p-6 rounded-2xl backdrop-blur-lg bg-white/40 shadow-lg">
      <h2 className="text-xl font-semibold text-center mb-4">üé§ Voice Ordering Assistant</h2>

      <select
        value={language}
        onChange={(e) => setLanguage(e.target.value)}
        className="w-full mb-4 p-2 rounded-lg border"
      >
        <option value="hi-IN">üáÆüá≥ Hindi</option>
        <option value="en-IN">üá¨üáß English</option>
      </select>

      <div className="flex justify-center mb-4">
        <button
          onClick={handleMicClick}
          className={`p-6 rounded-full ${
            isListening ? "bg-red-500 animate-pulse" : "bg-orange-500"
          } text-white`}
        >
          {isListening ? <MicOff size={36} /> : <Mic size={36} />}
        </button>
      </div>

      {processing && (
        <div className="flex justify-center text-orange-600">
          <Loader2 className="animate-spin" size={18} />
          <span className="ml-2">Processing...</span>
        </div>
      )}

      {orderResult && (
        <p className="p-3 mt-3 bg-green-100 text-green-700 rounded-lg text-center">
          {orderResult}
        </p>
      )}
    </div>
  );
};

export default VoiceOrderAssistant;
